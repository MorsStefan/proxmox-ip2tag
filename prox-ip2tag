#!/bin/bash

# https://github.com/MorsStefan/proxmox-ip2tag/
# Łukasz Dyś | Mors Stefan
# 2025-04-21 | ver 0.7.6

#-------------------------------------------------------------------------------
#          Do not modify this file.
#          Instead, edit: '/usr/local/etc/prox-ip2tag.conf'
#-------------------------------------------------------------------------------

# Defines which guest types to process: 1 = LXC, 2 = VM, 3 = both.
use_ip_tags_for=3

# The IP address range (in CIDR format) in which IP must be located in order to
# be automatically added or removed as IP tag.  Each range on a new line.
# Well known private networks: 10.0.0.0/24 192.168.0.0/24
# Use 0.0.0.0/0 to search for every possible IP'a
networks_range=(
    0.0.0.0/0
)

# Ignore these LXCs and VMs. 
ignored_vm_lxc_list=(
)

# Do not auto add or remove these IP tags for VMs and LXCs, do not change their color.
ignored_ip_tag_list=(
    127.0.0.1
)

# Allow changing Proxmox default tags colors: [ 0 | 1 ].
# Overwrites inactive_ip_tag_action when set to change_color or none.
change_tags_colors=1

# What to do with IP tags when VM/LXC is stopped: [ remove | change_color | none ].
inactive_ip_tag_action='change_color'

# Time in seconds between IP tags updates. Must be > 0. Minimum 60 is recommended.
update_ip_tags_interval=60

# Controls the placement of newly added IP tags: [ first | last ].
# Require: Datacenter->Options->Tag Style Override->Ordering='Configuration'
ip_tags_pos='first'

# Enforces a fixed position for IP tags according to the value of the 'ip_tags_pos'.
# Require: Datacenter->Options->Tag Style Override->Ordering='Configuration'
force_ip_tags_pos=1

# Active and inactive tag colors (hex)
tag_color='ffffff'
tag_bgcolor='000000'
tag_inactive_color='ffffff'
tag_inactive_bgcolor='aaaaaa'

# Method for reading tags and selected config options: [ cfg_files | qm_pct ].
# cfg_files = fast (reads local config files), qm_pct = use default Proxmox tools.
read_vm_lxc_config_using='cfg_files'

# Prefixes each output line with a timestamp - useful for terminal logging.
display_timestamp=0

# Verbosity level of log messages: [ 0 | 1 | 2 | 3 | 4 | 5 | 6 ].
# 0-reserved, 1-errors, 2-warnings|notice, 3-info, 4-verbose, 5-debug, 6-maximum
VERBOSE=3



#=[ Functions ]====================================================



function is_num() { [[ "$1" =~ ^-?([1-9][0-9]*|0)$ ]] }

function in_arr () { local e IFS; for e in "${@:2}"; do [ "$e" == "$1" ] && return 0; done; return 1; }

function in_network_range() {
    valid_ipv4 "$1" && ip_in_networks_range "$1" && return 0 || return 1
}

function is_ignored_tag() { [ -n "$1" ] && in_arr "$1" "${ignored_ip_tag_list[@]}"; }

function is_ignored_vm() {
    [ -z "$1" ] && return 1
    [[ " ${ignored_vm_lxc_list[*]} " == *" ${1} "* ]] && return 0 || return 1
}

function is_active_ip() { [[ -n "$2" ]] && in_arr "$@"; }

function is_inactive_ip() { [[ -z "$2" ]] || ! is_active_ip "$@"; }

function valid_ipv4() {
    local ip="$1"
    [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
    for i in ${ip//./ }; do
        [[ "${#i}" -gt 1 && "${i:0:1}" == 0 ]] && return 1
        [[ "$i" -gt 255 ]] && return 1;
    done
    return 0
}

function valid_cidr() {
    local cidr="$1"
    [ -z "$cidr" ] && return 1
    local ip="${cidr%/*}" subnet="${cidr#*/}"
    # Exception for 'normal' IP address
    # [[ "$cidr" != */* ]] && valid_ipv4 "$cidr" && return 0 || return 1
    if valid_ipv4 "$ip" && is_num "$subnet" && (( subnet >= 0 && subnet <= 32 )); then
        return 0
    fi
    return 1
}

function ip_in_networks_range() {
    local ip="$1"
    for network in "${networks_range[@]}"; do
	local ip_num subnet_num mask
	IFS=. read -r a b c d <<< "$ip"
	ip_num=$(( (a<<24)+(b<<16)+(c<<8)+d ))
	IFS=/ read subnet mask <<< "$network"
	IFS=. read -r e f g h <<< "$subnet"
	subnet_num=$(( (e<<24)+(f<<16)+(g<<8)+h ))
	mask=$(( 0xFFFFFFFF << (32-mask) & 0xFFFFFFFF ))
	(( (ip_num & mask) == (subnet_num & mask) )) && return 0
    done
    return 1
}

function verb() {
    local dat txt="$2"
    [ "$display_timestamp" == "1" ] && dat="$(date +'%F %T') | "
    if is_num "$1" && (( VERBOSE >= $1 )); then
	[ "$2" ] && echo "$dat$txt" || echo "$dat"
    fi
    return 0;
}



#=[ VM/LXC Countainers ]================================================



function join_tags() {
    [ -z "${*}" ] || echo "${*}" | xargs | tr ' ' ','; 
    return
}

# Works with VM and LXC. Results are unique and in proper order.
# global vars: guest_tags, guest_agent
find_tags_for_guest() {
    [[ "$1" == "lxc" || "$1" == "vm" ]] || return
    local type="$1" vmid="$2" conf line tag cmd_out
    guest_tags=()
    guest_agent=''

    if [ "$read_vm_lxc_config_using" == 'qm_pct' ]; then
	if [ "$type" == 'lxc' ]; then
	    cmd_out="$(pct config $vmid)"
	    [ $? -gt 0 ] && verb 1 "pct config $vmid: [Critical error] read config failed. Exiting." && exit 1
	else
            cmd_out="$(qm config $vmid)"
	    [ $? -gt 0 ] && verb 1 "qm config $vmid: [Critical error] read config failed. Exiting." && exit 1
            guest_agent="$(echo "$cmd_out" | awk -F': ' '/^agent:/ {print $2}' | cut -d, -f1 | xargs)"
	fi
        mapfile -t guest_tags < <(echo "$cmd_out" | awk -F': ' '/^tags:/ {print $2}' | xargs | tr ';' '\n')
	return 0
    fi

    [ "$type" == "lxc" ] && conf="/etc/pve/lxc/${vmid}.conf"
    [ "$type" == "vm"  ] && conf="/etc/pve/qemu-server/${vmid}.conf"
    if [ ! -f "$conf" ]; then
	verb 1 "$vmid: [Critical error] file not found '$conf'. Exiting."
	exit 1
    fi

    while IFS= read -r line; do
        [[ "$line" =~ ^\[.*\] ]] && break
        if [[ "$line" =~ ^tags: ]]; then
            for tag in $(echo "$line" | awk -F': ' '{print $2}' | tr ';' '\n'); do
                if [[ ! " ${guest_tags[@]} " =~ " ${tag} " ]]; then
                    [ "$tag" ] && guest_tags+=("$tag")
                fi
            done
        fi
        if [[ "$line" =~ ^agent: ]]; then
	    guest_agent="$(echo "${line#*: }" | cut -d, -f1 | xargs)"
	fi

    done < "$conf"

    return 0
}

# Update tags in VM/LXC
function update_tags() {
    [[ "$1" == "lxc" || "$1" == "vm" ]] || return

    local type="$1" cur_tags=() new_tags=() new_tags_tmp cur_tags_tmp cmd_out vm_list vm_ips_list=() ip
    local ttype="${type^^}"

    verb 4; verb 4 "$ttype update tags"; verb 4 "- - - - - - - -"

    if [ "$type" == 'lxc' ]; then
    	cmd_out="$( pct list )"
	[ $? -gt 0 ] && verb 1 "pct list: [Critical error] reading container list failed. Exiting." && exit 1
	vm_list="$( echo "$cmd_out" | awk 'NR>1 {print $1, $2}' )"
    else
    	cmd_out="$( qm list )"
	[ $? -gt 0 ] && verb 1 "qm list: [Critical error] reading virtual machine list failed. Exiting." && exit 1
	vm_list="$( echo "$cmd_out" | awk 'NR>1 {print $1, $3}' )"
    fi

    while read -r vmid status _; do
	
	! [[ "$vmid" && "$status" ]] && continue

	new_tags=()
	cur_tags=()
	vm_ips_list=()

	verb 6

        # Ignore these vm/lxc
        is_ignored_vm "$vmid" && verb 4 "$vmid: no changes [ $type ignored ]" && continue

        # Read all tags from VM/LXC and 'guest_agent'
	find_tags_for_guest "$type" "$vmid"
	cur_tags=("${guest_tags[@]}")

	# Collect IP from running VM/lxC
	if [ "$status" == 'running' ]; then

            # List IP's of VM/LXC
	    if [ "$type" == 'lxc' ]; then
        	mapfile -t vm_ips_list < <(lxc-info -n "${vmid}" -i 2>/dev/null | awk '{print $2}')
	    else
		# With or without jq
		if [ $jqi -eq 1 ]; then
		    [ "$guest_agent" == "1" ] && mapfile -t vm_ips_list < <( qm guest cmd $vmid network-get-interfaces 2>/dev/null \
            		| jq -r '.[] | .["ip-addresses"]? // [] | .[] | .["ip-address"]')
		else
		    [ "$guest_agent" == "1" ] && mapfile -t vm_ips_list < <( qm guest cmd $vmid network-get-interfaces 2>/dev/null \
            		| grep '"ip-address"' | awk -F'"' '{print $4}' )
		fi
	    fi

            # Skip VM if guest agent=0 [maybe add IP lookup with a simple network scan and ARP table?]
	    [ "$guest_agent" == "0" ] && verb 4 "$vmid: no changes [ guest agent disabled ]" && continue

            # Skip if VM/LXC has no IP
	    [ "$vm_ips_list" == "" ] && verb 2 "$vmid: [Warning] $ttype is running, but no IP was return." && continue

	    # Add all IP's to active ip tags
	    for ip in "${vm_ips_list[@]}"; do
        	in_network_range "$ip" && active_ip_tags+=("$ip") && verb 6 "$vmid: active IP -> '$ip'"
	    done

	    # Sorting order of IP addresses retrieved from the VM
	    vm_ips_list=( $(printf "%s\n" "${vm_ips_list[@]}" | sort -u -V -r) )

	# Collect IP from stopped VM/lxC
	else
    	    for cur_tag in "${cur_tags[@]}"; do
        	in_network_range "$cur_tag" && inactive_ip_tags+=("$cur_tag") && verb 6 "$vmid: inactive IP -> '$cur_tag'"
	    done
	fi

	# Again ...
	if [ "$status" == 'running' ]; then

	    verb 6 "$vmid: vm_ips_list: '${vm_ips_list[*]}'"

	    # I know it could have been done in one loop...
	    if [ "$force_ip_tags_pos" == "0" ]; then
		for cur_tag in "${cur_tags[@]}"; do
		    verb 5 "$vmid: cur_tag -> $cur_tag"
        	    # Add ignored tags
        	    is_ignored_tag "$cur_tag" && new_tags+=("$cur_tag") && continue
		    # Dont add inactive IP
		    if in_network_range "$cur_tag" && ! is_active_ip "$cur_tag" "${vm_ips_list[@]}"; then
			inactive_ip_tags+=("$cur_tag")
			verb 4 "$vmid: IP in network range but not active: $cur_tag"			
			continue
		    fi
		    # Add other tags
		    new_tags+=("$cur_tag")
		done
	    else
		for cur_tag in "${cur_tags[@]}"; do
		    verb 5 "$vmid: cur_tag -> $cur_tag"
        	    # Add ignored tags
        	    is_ignored_tag "$cur_tag" && new_tags+=("$cur_tag") && continue
		    # Dont add from our network range
		    if in_network_range "$cur_tag"; then
			verb 5 "$vmid: IP in network range and active: $cur_tag"
			continue
		    fi
		    # Add other tags
		    new_tags+=("$cur_tag")
		done
	    fi
	    
	    # Add active IP tags from running VM [if not ignored] at the begin or end
	    for vm_ip in "${vm_ips_list[@]}"; do
		if in_network_range "$vm_ip" && ! is_ignored_tag "$vm_ip"; then
		    if ! is_active_ip "$vm_ip" "${new_tags[@]}"; then
                        if [ "$ip_tags_pos" == "last" ]; then
			    new_tags+=("${vm_ip}")
			else
			    new_tags=("${vm_ip}" ${new_tags[*]})
			fi
			verb 5 "$vmid: found new IP in network range and active: $vm_ip"
		    fi
		fi
	    done

	# Stopped VM [ new wersion with sorting ]
	else
	    if [ "$inactive_ip_tag_action" == "remove" ]; then
		for cur_tag in "${cur_tags[@]}"; do
		     # Add ignored tags
		    is_ignored_tag "$cur_tag" && new_tags+=("$cur_tag") && continue
		    in_network_range "$cur_tag" || new_tags+=("$cur_tag")
		done
	    else
		# verb 4 "$vmid: no changes" && continue # uncomment to disable sorting stopped
		# Sorting stopped VM/LXC

		[ "$force_ip_tags_pos" == "0" ] && verb 4 "$vmid: no changes" && continue

		# Remove IP tags from the range, but keep ignored ones
		for cur_tag in "${cur_tags[@]}"; do
		    if is_ignored_tag "$cur_tag"; then
		        new_tags+=("$cur_tag")
		    elif ! in_network_range "$cur_tag"; then
		        new_tags+=("$cur_tag")
		    fi
		done

		# Now using IP tags from range and not ignored
		ip_tags_range_ordered=()
		other_tags=()

		for cur_tag in "${cur_tags[@]}"; do
		    if is_ignored_tag "$cur_tag" || ! in_network_range "$cur_tag"; then
		        other_tags+=("$cur_tag")
		    else
		        ip_tags_range_ordered+=("$cur_tag")
		    fi
		done

		# Placing tags as defined by ip_tags_pos
		if [ "$ip_tags_pos" == "last" ]; then
		    new_tags=( "${other_tags[@]}" "${ip_tags_range_ordered[@]}" )
		else
		    new_tags=( "${ip_tags_range_ordered[@]}" "${other_tags[@]}" )
		fi

	    fi

	fi
	# [ new wersion with sorting END ]

	cur_tags_tmp=$(join_tags ${cur_tags[*]})
	new_tags_tmp=$(join_tags ${new_tags[*]})

	verb 5 "$vmid: cur tags tmp: '$cur_tags_tmp'"
	verb 5 "$vmid: new tags tmp: '$cur_tags_tmp'"

        if [ "$ordering" == "config" ]; then
            if [[ "$new_tags_tmp" == "$cur_tags_tmp" ]]; then
                verb 4 "$vmid: no changes"
                continue
            fi
        else
    	    if [[ "$(printf "%s\n" "${new_tags[@]}" | sort -u)" == "$(printf "%s\n" "${cur_tags[@]}" | sort -u)" ]]; then
                verb 4 "$vmid: no changes"
                continue
            fi
        fi

	verb 5 "$vmid:    old tags -> '$cur_tags_tmp'"
	verb 5 "$vmid:    new tags -> '$new_tags_tmp'"
	verb 3 "$vmid: [update tags] from '$cur_tags_tmp' to '$new_tags_tmp'"

	if [ "$type" == 'lxc' ]; then
	    pct set "${vmid}" -tags "$new_tags_tmp" &>/dev/null
	else
	    qm set "${vmid}" -tags "$new_tags_tmp" &>/dev/null
	fi
	[ $? -gt 0 ] && verb 1 "$vmid: [Error] update $ttype tags failed." && continue

    done <<< "$vm_list"

    verb 6
    verb 6 "  active_ip_tags: '${active_ip_tags[*]}'"
    verb 6 "inactive_ip_tags: '${inactive_ip_tags[*]}'"
}

function updates_vm_tags_and_tags_colors() {
    active_ip_tags=()
    inactive_ip_tags=() 

    (( use_ip_tags_for & 1 )) && update_tags 'lxc'
    (( use_ip_tags_for & 2 )) && update_tags 'vm'

    verb 4; verb 4 "Tags colors"; verb 4 "- - - - - - - -"

    [ $change_tags_colors -eq 0 ] && verb 4 "change_tags_colors: option disabled." && return

    read_cluster_config
    cur_color_map="$color_map"

    active_ip_tags=( $(printf "%s\n" "${active_ip_tags[@]}" | sort -u -V) )
    inactive_ip_tags=( $(printf "%s\n" "${inactive_ip_tags[@]}" | sort -u -V) )

    # Change tags color [inactive]
    if [ "$inactive_ip_tag_action" == 'change_color' ]; then
	for inact_ip in "${inactive_ip_tags[@]}"; do
	    if is_ignored_tag "$inact_ip"; then
		verb 6  "inactive: $inact_ip [ ignored ]"
	    else
		verb 6  "inactive: $inact_ip"
		color_map_update "$inact_ip:$tag_inactive_bgcolor:$tag_inactive_color"
	    fi
	done
    fi

    # Change tags color [active]
    for act_ip in "${active_ip_tags[@]}"; do
	if is_ignored_tag "$act_ip"; then
	    verb 6  "active: $act_ip [ ignored ]"
	else
	    verb 6  "active: $act_ip"
	    color_map_update "$act_ip:$tag_bgcolor:$tag_color"
	fi
    done

    [ "$cur_color_map" == "$color_map" ] && verb 4 "color-map: no changes" && return

    verb 6 "cur_color-map: '$cur_color_map'"
    verb 6 "    color-map: '$color_map'"
    verb 6
    verb 3 "color-map: updating tags to new colors"

    config_string="$(build_config_string)"
    pvesh set /cluster/options --tag-style "color-map=$config_string" &>/dev/null
    [ $? -gt 0 ] && verb 1 "pvesh set: [Error] update cluster options failed."
}



#=[ Cluster functions ]=================================================



function read_cluster_config() {
    local cmd_out clean_key

    # Read cluster options: case-sensitive|shape|ordering|color-map
    cmd_out="$(pvesh get /cluster/options --noborder 1 --noheader 1 --output-format json-pretty)"
    [ $? -gt 0 ] && verb 1 "pvesh get: [critical error] read cluster options failed. Exiting." && exit 1

    ordering=''
    case_sensitive=''
    shape=''
    color_map=''

    if [ $jqi -eq 1 ]; then
	while IFS== read -r key value; do
    	    case "$key" in
    		"case-sensitive"|"shape"|"ordering"|"color-map")
        	clean_key=$(echo "$key" | tr '-' '_')
        	declare -g "$clean_key=$value"
    	    ;;
    	    esac
	done < <( echo "$cmd_out" | jq -r '.["tag-style"] | to_entries[] | "\(.key)=\(.value)"' )
    else
	case_sensitive=$(echo "$cmd_out" | grep '"case-sensitive" :' | cut -d ':' -f2 | tr -d ' ,')
	color_map=$(echo "$cmd_out" | grep '"color-map" :' | cut -d ':' -f2- | cut -d '"' -f2)
	ordering=$(echo "$cmd_out" | grep '"ordering" :' | cut -d ':' -f2 | tr -d ' ",' )
	shape=$(echo "$cmd_out" | grep '"shape" :' | cut -d ':' -f2 | tr -d ' ",' )
    fi
    verb 4 "read cluster options"
    verb 5 "/cluster/options: -> ordering='$ordering' | case_sensitive='$case_sensitive' | shape='$shape'"
}

function color_map_update() {
    local in_tag="$1"
    [ -z "$in_tag" ] && return 1

    local prefix="${in_tag%%:*}:"
    local tmp=$(echo "$color_map" | tr ';' '\n' | grep -v "^${prefix}")
    tmp=$(printf "%s\n%s" "$tmp" "$in_tag" | sort -V -u | paste -sd ';')
    color_map="${tmp#;}"
}

function build_config_string() {
    local config=""

    [ -n "$color_map" ]      && config="$color_map,"
    [ -n "$case_sensitive" ] && config+="case-sensitive=$case_sensitive,"
    [ -n "$ordering" ]       && config+="ordering=$ordering,"
    [ -n "$shape" ]          && config+="shape=$shape,"

    config="${config#;}"
    echo "${config%,}"
}



#=[ MAIN ]==============================================================



function p_init() {
    local cmd var LOCK_FILE="/var/lock/prox-ip2tag.lock"

    exec 200>"$LOCK_FILE"
    flock -n 200 || {
	verb 1 "[Critical error] Another instance of prox-ip2tag is already running."
	verb 1 "If you're sure no other instance is active, remove the lock file:"
	verb 1 "  sudo rm -f $LOCK_FILE"
	exit 1
    }

    # Read user config file
    [ -f "/usr/local/etc/prox-ip2tag.conf" ] && source /usr/local/etc/prox-ip2tag.conf

    # Check the necessary programs
    for cmd in qm pct pvesh lxc-info bc; do
	command -v "$cmd" &>/dev/null || { verb 1 "[Critical error] Missing required Proxmox component: '$cmd'"; exit 1; }
    done

    if command -v jq &>/dev/null; then
	jqi=1
    else
	jqi=0
	verb 2 "[Notice] 'jq' is not installed, proceeding anyway."
    fi

    # Checking config values
    [[ ! "$use_ip_tags_for" =~ ^[123]$ ]] \
	&& verb 1 "[Critical error] Bad value for: use_ip_tags_for -> '$use_ip_tags_for'" && exit 1

    [[ ! "$read_vm_lxc_config_using" =~ ^(cfg_files|qm_pct)$ ]] \
	&& verb 1 "[Critical error] Bad value for: read_vm_lxc_config_using -> '$read_vm_lxc_config_using'" && exit 1

    [[ ! "$inactive_ip_tag_action" =~ ^(change_color|none|remove)$ ]] \
	&& verb 1 "[Critical error] Bad value for: inactive_ip_tag_action -> '$inactive_ip_tag_action'" && exit 1

    [[ ! "$ip_tags_pos" =~ ^(first|last)$ ]] \
	&& verb 1 "[Critical error] Bad value for: ip_tags_pos -> '$ip_tags_pos'" && exit 1

    [[ ! "$change_tags_colors" =~ ^[01]$ ]] \
	&& verb 1 "[Critical error] Bad value for: change_tags_colors -> '$change_tags_colors'" && exit 1

    [[ ! "$display_timestamp" =~ ^[01]$ ]] \
	&& verb 1 "[Critical error] Bad value for: display_timestamp -> '$display_timestamp'" && exit 1

    [[ ! "$force_ip_tags_pos" =~ ^[01]$ ]] \
	&& verb 1 "[Critical error] Bad value for: force_ip_tags_pos -> '$force_ip_tags_pos'" && exit 1

    [[ ! "$VERBOSE" =~ ^[0123456]$ ]] \
	&& verb 1 "[Critical error] Bad value for: VERBOSE -> '$VERBOSE'" && exit 1

    if ! [[ "$update_ip_tags_interval" =~ ^[0-9]+$ && "$update_ip_tags_interval" -gt 0 ]]; then
	verb 1 "[Critical error] Bad value for: update_ip_tags_interval -> '$update_ip_tags_interval'"
	exit 1
    fi

    for var in tag_inactive_color tag_inactive_bgcolor tag_color tag_bgcolor; do
	val="${!var}"
	[[ ! "$val" =~ ^[0-9a-fA-F]{6}$ ]] && verb 1 "[Critical error] Bad value for: $var -> '$val'" && exit 1
	declare -gl "$var=${val}"
    done

    for val in "${ignored_vm_lxc_list[@]}"; do
	! is_num "$val" && verb 1 "[Critical error] Bad value in: ignored_vm_lxc_list -> '$val'" && exit 1
    done

    for val in "${networks_range[@]}"; do
	! valid_cidr "$val" && verb 1 "[Critical error] Bad value in: networks_range -> '$val'" && exit 1
    done

    for val in "${ignored_ip_tag_list[@]}"; do
	! valid_ipv4 "$val" && verb 1 "[Critical error] Bad value in: ignored_ip_tag_list -> '$val'" && exit 1
    done

    update_ip_tags_last_run=0
    read_cluster_config
}

function main() {
    p_init

    while true; do
	now="$(date +%s)"
	if (( now - update_ip_tags_last_run >= update_ip_tags_interval )); then
	    updates_vm_tags_and_tags_colors
	    update_ip_tags_last_run=$(date +%s)
	fi
	[ "$1" == '--run-once' ] && exit
	# [ "$(tty)" ] && exit 0
	verb 4
	verb 4 "sleep 5s"
	sleep 5
    done
}

main

# Todo
# - use LXC/VM list from cluster instead of pct|qm 
# - checking IP numbers from the configuration for LXCs (when stopped) (?)
# - IP lookup using ethernet addr. and arp table for non-guest VMs (?)
